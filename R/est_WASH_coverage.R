#' Estimate and Visualize WASH Coverage and Correlation with Cholera Incidence
#'
#' This function processes Water, Sanitation, and Hygiene (WASH) coverage data for African countries, optimizes the weights of WASH variables, calculates weighted means, and examines their correlation with cholera incidence. The function generates plots and tables showing these relationships and saves the results to specified paths.
#'
#' @param PATHS A list containing paths where the WASH data, figures, and model inputs should be saved. Typically generated by the `get_paths()` function and should include:
#' \itemize{
#'   \item \strong{DATA_WASH}: Path to the WASH data CSV file.
#'   \item \strong{DOCS_FIGURES}: Path to save output figures.
#'   \item \strong{MODEL_INPUT}: Path to save model input data.
#'   \item \strong{DOCS_TABLES}: Path to save tables used in documentation.
#' }
#'
#' @return The function does not return a value, but generates and saves plots and CSV files showing WASH coverage estimates, optimized weights for WASH variables, and their correlation with cholera incidence.
#'
#' @details
#' The WASH coverage data is first normalized (on a 0-1 scale). Risk-related WASH variables (such as unimproved water sources, surface water, unimproved sanitation, and open defecation) are converted to protective factors by taking the complement (1 - value). Then, the function:
#' \itemize{
#'   \item Optimizes the weights for each WASH variable to maximize correlation with cholera incidence using the L-BFGS-B method.
#'   \item Calculates the weighted mean of WASH variables for each country.
#'   \item Generates multiple plots showing relationships between WASH variables and cholera incidence.
#'   \item Saves tables of optimized weights and weighted mean WASH indices.
#' }
#'
#' Data Source: Sikder et al. (2023). Water, Sanitation, and Hygiene Coverage and Cholera Incidence in Sub-Saharan Africa. \doi{10.1021/acs.est.3c01317}.
#'
#' @importFrom ggplot2 ggplot geom_point geom_smooth geom_bar geom_text labs scale_x_continuous scale_y_continuous theme_minimal theme element_text element_blank
#' @importFrom reshape2 melt
#' @importFrom dplyr mutate group_by
#' @importFrom gtools rdirichlet
#' @importFrom countrycode countrycode
#' @importFrom cowplot plot_grid
#' @importFrom utils read.csv write.csv
#' @importFrom stats optim cor
#'
#' @examples
#' \dontrun{
#' # Define paths for saving WASH data, figures, and tables
#' PATHS <- get_paths()
#'
#' # Estimate WASH coverage and correlation with cholera incidence
#' est_WASH_coverage(PATHS)
#' }
#'
#' @export


est_WASH_coverage <- function(PATHS) {

     requireNamespace('ggplot2')
     requireNamespace('reshape2')
     requireNamespace('dplyr')
     requireNamespace('gtools')
     requireNamespace('countrycode')

     path <- file.path(PATHS$DATA_WASH, "WASH_data_Sikder_2023.csv")
     wash_data <- read.csv(path, stringsAsFactors = FALSE)

     # Put on 0 to 1 scale and make present risk variables as complement (1 - value)
     wash_variables <- colnames(wash_data)[2:9]
     wash_variables_protective <- colnames(wash_data)[2:5]
     wash_variables_risk <- colnames(wash_data)[6:9]

     wash_data[,wash_variables] <- wash_data[,wash_variables]/100
     wash_data[,wash_variables_risk] <- 1 - wash_data[,wash_variables_risk]



     ################################################################################
     # Find weighted index
     ################################################################################

     # Define the function to calculate weighted mean and return the negative correlation (for optimization)
     calculate_weighted_correlation <- function(weights, data, wash_vars) {
          # Ensure weights sum to 1
          weights <- weights / sum(weights)

          # Calculate the weighted mean of WASH variables
          weighted_mean <- rowSums(sweep(data[, wash_vars], 2, weights, `*`))

          # Calculate the correlation with incidence
          correlation <- cor(weighted_mean, data$Incidence_per_1000, use = "complete.obs")

          # Return the negative correlation because optim minimizes the objective function
          return(correlation)
     }


     # Set a seed for reproducibility
     set.seed(123)

     # Generate initial weights using a Dirichlet distribution
     #initial_weights <- gtools::rdirichlet(1, alpha = rep(1, length(wash_variables)))
     initial_weights <- rep(1/length(wash_variables), length(wash_variables))


     # Optimize the weights to maximize the correlation with incidence
     optimal_weights <- optim(par = initial_weights,
                              fn = calculate_weighted_correlation,
                              data = wash_data,
                              wash_vars = wash_variables,
                              method = "L-BFGS-B",
                              lower = rep(0, length(wash_variables)),
                              upper = rep(1, length(wash_variables)),
                              control = list(maxit = 5000))

     # Extract the optimized weights
     best_weights <- optimal_weights$par / sum(optimal_weights$par)  # Normalize to sum to 1




     # Calculate the weighted mean using the optimized weights
     wash_data$Weighted_Mean_WASH <- rowSums(sweep(wash_data[, wash_variables], 2, best_weights, `*`))

     # Calculate the correlation with incidence
     best_correlation <- cor(wash_data$Weighted_Mean_WASH, wash_data$Incidence_per_1000, use = "complete.obs")

     # Print the best weights and the corresponding correlation
     print(paste("Optimized Weights:", paste(round(best_weights, 4), collapse = ", ")))
     print(paste("Best Correlation with Incidence:", round(best_correlation, 4)))






     ################################################################################
     # Plot relationships bt WASH and incidence
     ################################################################################

     wash_data$Mean_WASH <- rowMeans(wash_data[, wash_variables])

     # Add the Best Weighted Mean to the list of variables for plotting
     wash_data_long <- melt(wash_data, id.vars = c("Country", "Incidence_per_1000"),
                            measure.vars = c(wash_variables, "Mean_WASH", "Weighted_Mean_WASH"), variable.name = "WASH_Variable", value.name = "Value")

     wash_data_long$protective <- ifelse(wash_data_long$WASH_Variable %in% wash_variables_protective, 1, 0)
     wash_data_long$risk <- ifelse(wash_data_long$WASH_Variable %in% wash_variables_risk, 1, 0)
     wash_data_long$means <- ifelse(wash_data_long$WASH_Variable %in% c("Mean_WASH", "Weighted_Mean_WASH"), 1, 0)

     # Recalculate correlations to include Weighted_Mean_WASH
     correlations_weighted <- sapply(c(wash_variables, "Mean_WASH", "Weighted_Mean_WASH"), function(var) {
          cor(wash_data[[var]], wash_data$Incidence_per_1000, use = "complete.obs")
     })


     wash_data_long <- wash_data_long %>%
          group_by(WASH_Variable) %>%
          mutate(correlation_label = paste0("r = ", round(correlations_weighted[WASH_Variable], 2)))





     tmp <- wash_data_long[wash_data_long$protective == 1,]
     tmp$WASH_Variable <- gsub("_", " ", tmp$WASH_Variable)
     tmp$WASH_Variable <- factor(tmp$WASH_Variable,
                                 levels=c("Piped Water", "Septic or Sewer Sanitation", "Other Improved Water", "Other Improved Sanitation"))

     p1 <-
          ggplot(tmp, aes(x = Value, y = Incidence_per_1000)) +
          geom_point(color = "black", size = 2, alpha=0.6) +
          geom_smooth(color = "#2ecc71", method = "lm", se = FALSE, linewidth = 1) +
          facet_wrap(~ WASH_Variable, scales = "free_x") +
          geom_text(aes(label = correlation_label), x = Inf, y = Inf, hjust = 1.75, vjust = 2, size = 3.5, color = "black") +
          labs(title = "A",
               subtitle = "Protective WASH variables",
               x = NULL,
               y = "Incidence per 1,000") +
          scale_x_continuous(limits = c(0,1)) +
          theme_minimal() +
          theme(plot.title = element_text(size = 13, face = "bold"),
                plot.subtitle = element_text(size = 13, face='bold', hjust = 0.5),
                axis.title.x = element_text(size = 12, margin = margin(t = 20)),
                axis.title.y = element_text(size = 12, margin = margin(r = 20)),
                axis.text = element_text(size = 10),
                strip.text = element_text(size = 12),
                legend.position = "none",
                panel.grid.minor = element_blank())




     tmp <- wash_data_long[wash_data_long$risk == 1,]
     tmp$WASH_Variable <- gsub("_", " ", tmp$WASH_Variable)
     tmp$WASH_Variable <- factor(tmp$WASH_Variable,
                                 levels=c("Surface Water", "Open Defecation", "Unimproved Water", "Unimproved Sanitation"))


     p2 <-
          ggplot(tmp, aes(x = Value, y = Incidence_per_1000)) +
          geom_point(color = "black", size = 2, alpha=0.6) +
          geom_smooth(color = "#e67e22", method = "lm", se = FALSE, size = 1) +
          facet_wrap(~ WASH_Variable, scales = "free_x") +
          geom_text(aes(label = correlation_label), x = Inf, y = Inf, hjust = 1.75, vjust = 2, size = 3.5, color = "black") +
          labs(title = "B",
               subtitle = "Risk WASH variables (1-value)",
               x = NULL,
               y = "Incidence per 1,000") +
          scale_x_continuous(limits = c(0,1)) +
          theme_minimal() +
          theme(plot.title = element_text(size = 13, face = "bold"),
                plot.subtitle = element_text(size = 13, face='bold', hjust = 0.5),
                axis.title.x = element_text(size = 12, margin = margin(t = 20)),
                axis.title.y = element_text(size = 12, margin = margin(r = 20)),
                axis.text = element_text(size = 10),
                strip.text = element_text(size = 12),
                legend.position = "none",
                panel.grid.minor = element_blank())



     tmp <- wash_data_long[wash_data_long$means == 1,]
     tmp$WASH_Variable <- gsub("_", " ", tmp$WASH_Variable)
     tmp$WASH_Variable <- factor(tmp$WASH_Variable,
                                 levels=c("Weighted Mean WASH", "Mean WASH"))

     p3 <-
          ggplot(tmp, aes(x = Value, y = Incidence_per_1000)) +
          geom_point(color = "black", size = 2, alpha=0.6) +
          geom_smooth(color = "#9b59b6", method = "lm", se = FALSE, size = 1) +
          facet_wrap(~ WASH_Variable, scales = "free_x") +
          geom_text(aes(label = correlation_label), x = Inf, y = Inf, hjust = 1.75, vjust = 2, size = 3.5, color = "black") +
          labs(title = "C",
               subtitle = "Mean WASH variables",
               x = "WASH variable value",
               y = "Incidence per 1,000") +
          scale_x_continuous(limits = c(0,1)) +
          theme_minimal() +
          theme(plot.title = element_text(size = 13, face='bold'),
                plot.subtitle = element_text(size = 13, face='bold', hjust = 0.5),
                axis.title.x = element_text(size = 12, margin = margin(t = 20)),
                axis.title.y = element_text(size = 12, margin = margin(r = 20)),
                axis.text = element_text(size = 10),
                strip.text = element_text(size = 12),
                legend.position = "none",
                panel.grid.minor = element_blank())


     combo <- cowplot::plot_grid(p1, p2, p3, ncol=1, rel_heights = c(1,1,0.7), align = "vh", axis='tb')
     combo


     path <- file.path(PATHS$DOCS_FIGURES, "wash_incidence_correlation.png")

     png(filename = path, height = 3200, width = 2000, units = "px", res=300)
     combo
     dev.off()

     message(paste("WASH v incidence plot saved here: ", path))


     ################################################################################
     # Plot values of optimized weighted mean WASH index by country
     # There are the values used in the model as theta_j
     ################################################################################

     p4 <-
          ggplot(wash_data, aes(x = reorder(Country, -Weighted_Mean_WASH), y = Weighted_Mean_WASH)) +
          geom_bar(stat = "identity", fill = "steelblue") +
          geom_hline(yintercept = 0) +
          labs(x = NULL, y = "Optimized Weighted Mean\nof WASH Variables (θ)") +  # Wrap the y-axis title and add (θ)
          scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
          theme_minimal() +
          theme(
               plot.title = element_text(size = 16, face = "bold"),
               axis.ticks.x = element_line(size = 0.5),
               axis.ticks.y = element_line(size = 0.5),
               axis.text = element_text(size = 12),
               axis.text.x = element_text(angle = 45, hjust = 1),
               axis.title.y = element_text(size = 14, margin = margin(r = 20), lineheight = 1.2),  # Lineheight for wrapping
               panel.grid.minor = element_blank(),
               panel.grid.major.x = element_blank()
          )




     path <- file.path(PATHS$DOCS_FIGURES, "wash_index_by_country.png")

     png(filename = path, height = 1750, width = 2750, units = "px", res=300)
     p4
     dev.off()

     message(paste("WASH index by country plot saved here: ", path))



     weights_table <- data.frame(
          WASH_variable = wash_variables,
          Optimized_weight = round(best_weights, 3)
     )

     weights_table$WASH_variable <- gsub("_", " ", weights_table$WASH_variable)

     weights_table <- weights_table[c(1,3,2,4,6,7,5,8),]
     print(weights_table)


     path <- file.path(PATHS$DOCS_TABLES, "WASH_data_weights.csv")
     write.csv(weights_table, file=path, row.names = FALSE)
     message("WASH weights table saved here:")
     message(path)



     param_df <- make_param_df(variable_name = 'theta',
                               variable_description = 'WASH coverage',
                               parameter_distribution = 'point',
                               j = wash_data$iso_code,
                               parameter_name = 'mean',
                               parameter_value = wash_data$Weighted_Mean_WASH)


     path1 <- file.path(PATHS$MODEL_INPUT, "param_theta_WASH.csv")
     path2 <- file.path(PATHS$DOCS_TABLES, "WASH_weighted_mean_theta.csv")

     write.csv(param_df, file=path1, row.names = FALSE)

     write.csv(wash_data[,c("Country", "iso_code", "Weighted_Mean_WASH")],
               file=path2, row.names = FALSE)

     message("WASH weighted mean (tau) saved here:")
     message(path1)
     message(path2)




     ################################################################################
     ################################################################################
     ################################################################################

     # Confidence intervals

     if (FALSE) {

          # Function to calculate the correlation and its 95% CI using bootstrapping
          bootstrap_correlation <- function(data, wash_var, n_bootstrap = 1000) {
               correlations <- replicate(n_bootstrap, {
                    sample_indices <- sample(1:nrow(data), replace = TRUE)
                    sampled_data <- data[sample_indices, ]
                    cor(sampled_data[[wash_var]], sampled_data$Incidence_per_1000, use = "complete.obs")
               })

               # Calculate mean and 95% CI
               mean_cor <- mean(correlations)
               ci_lower <- quantile(correlations, 0.025)
               ci_upper <- quantile(correlations, 0.975)

               return(c(mean = mean_cor, ci_lower = ci_lower, ci_upper = ci_upper))
          }


          # Calculate mean and 95% CI for each WASH variable's correlation coefficient
          correlation_results <- sapply(unique(as.character(wash_data_long$WASH_Variable)), function(var) {
               bootstrap_correlation(wash_data, var)
          })

          # Convert results to a data frame
          correlation_results_df <- data.frame(
               WASH_Variable = as.character(wash_data_long$WASH_Variable),
               Mean_Correlation = correlation_results["mean", ],
               CI_Lower = correlation_results["ci_lower.2.5%", ],
               CI_Upper = correlation_results["ci_upper.97.5%", ]
          )

          # Print the correlation results with CIs
          print(correlation_results_df)

     }

}
