#' Create Binary Environmental Suitability Indicator from Epidemic Peaks
#'
#' This function creates a deterministic binary indicator of environmental suitability for cholera
#' transmission based on epidemic peak periods identified by the \code{est_epidemic_peaks()} function.
#' It uses the exact peak_start and peak_stop dates without any modifications or lead-up periods.
#'
#' @param PATHS List of paths generated by get_paths() containing MODEL_INPUT path for accessing
#'   the epidemic peaks data file.
#'
#' @return A function that takes a data frame and returns it with an additional \code{cases_binary}
#'   column containing the binary environmental suitability indicator (0 = unsuitable, 1 = suitable).
#'   The input data frame must contain columns: \code{iso_code} and \code{date}.
#'
#' @details
#' This function implements a deterministic approach for creating environmental suitability indicators:
#'
#' \strong{Deterministic Epidemic Peak Method:}
#' \enumerate{
#'   \item Loads epidemic peak periods from \code{param_epidemic_peaks.csv}
#'   \item Marks all weeks from \code{peak_start} to \code{peak_stop} as suitable (1)
#'   \item Uses exact dates without any lead-up periods or duration filters
#'   \item Countries without epidemic peaks have cases_binary = 0 for all periods
#' }
#'
#' \strong{Key Features:}
#' \itemize{
#'   \item Deterministic behavior - no parameters that can alter the peak periods
#'   \item Direct use of peak_start and peak_stop dates from epidemic analysis
#'   \item No fallback methods or threshold-based logic
#'   \item Preserves missing data periods (NA) as non-suitable
#' }
#'
#' @examples
#' \dontrun{
#' # Load and apply epidemic peaks to data
#' PATHS <- get_paths()
#' peak_function <- get_cases_binary_from_peaks(PATHS)
#' data_with_binary <- peak_function(data)
#' }
#'
#' @note
#' Requires \code{param_epidemic_peaks.csv} file generated by \code{est_epidemic_peaks()}.
#' If this file is missing, the function will stop with an error.
#'
#' @seealso
#' \code{\link{est_epidemic_peaks}} for epidemic peak detection
#' \code{\link{process_suitability_data}} for the main data processing pipeline
#'
#' @export
get_cases_binary_from_peaks <- function(PATHS) {

    # Load epidemic peaks data
    peaks_file <- file.path(PATHS$MODEL_INPUT, "param_epidemic_peaks.csv")

    if (!file.exists(peaks_file)) {
        stop("Epidemic peaks file not found: ", peaks_file,
             "\nRun est_epidemic_peaks() first to generate this file.")
    }

    # Read epidemic peaks
    peaks <- read.csv(peaks_file, stringsAsFactors = FALSE)
    message(sprintf("Loaded epidemic peaks data: %d peak periods across %d countries",
                   nrow(peaks), length(unique(peaks$iso_code))))

    # Convert date columns to Date class
    peaks$peak_start <- as.Date(peaks$peak_start)
    peaks$peak_stop <- as.Date(peaks$peak_stop)

    # Return a function that applies epidemic peaks to data
    function(data) {

        # Input validation
        required_cols <- c("iso_code", "date")
        missing_cols <- setdiff(required_cols, names(data))
        if (length(missing_cols) > 0) {
            stop("Missing required columns: ", paste(missing_cols, collapse = ", "))
        }

        # Ensure date column is Date class
        if (!inherits(data$date, "Date")) {
            data$date <- as.Date(data$date)
        }

        # Initialize cases_binary column (all periods start as unsuitable)
        data$cases_binary <- 0

        # Get countries in data that have epidemic peaks
        data_countries <- unique(data$iso_code)
        peak_countries <- unique(peaks$iso_code)
        countries_with_peaks <- intersect(data_countries, peak_countries)
        countries_without_peaks <- setdiff(data_countries, peak_countries)

        message(sprintf("Applying epidemic peak-based suitability indicators:"))
        message(sprintf("  - Countries with epidemic peaks: %d (%s)",
                       length(countries_with_peaks),
                       paste(head(sort(countries_with_peaks), 6), collapse = ", ")))
        if (length(countries_with_peaks) > 6) {
            message(sprintf("    ... and %d more", length(countries_with_peaks) - 6))
        }

        if (length(countries_without_peaks) > 0) {
            message(sprintf("  - Countries without peaks (remain unsuitable): %d (%s)",
                           length(countries_without_peaks),
                           paste(head(sort(countries_without_peaks), 6), collapse = ", ")))
            if (length(countries_without_peaks) > 6) {
                message(sprintf("    ... and %d more", length(countries_without_peaks) - 6))
            }
        }

        # Apply epidemic peaks deterministically
        for (country in countries_with_peaks) {
            country_data_idx <- data$iso_code == country
            country_peaks <- peaks[peaks$iso_code == country, ]

            for (i in 1:nrow(country_peaks)) {
                peak_start <- country_peaks$peak_start[i]
                peak_stop <- country_peaks$peak_stop[i]

                # Find exact date indices for this peak period (peak_start to peak_stop inclusive)
                peak_indices <- which(country_data_idx &
                                     data$date >= peak_start &
                                     data$date <= peak_stop)

                # Mark all periods in peak as suitable (deterministic - no conditions)
                data$cases_binary[peak_indices] <- 1
            }
        }

        # Calculate and report summary statistics
        n_total <- nrow(data)
        n_suitable <- sum(data$cases_binary == 1, na.rm = TRUE)
        n_peaks_applied <- sum(peaks$iso_code %in% countries_with_peaks)

        message(sprintf("Epidemic peak-based environmental suitability applied:"))
        message(sprintf("  - Total observations: %d", n_total))
        message(sprintf("  - Peak periods applied: %d", n_peaks_applied))
        message(sprintf("  - Suitable periods: %d (%.1f%%)", n_suitable, 100 * n_suitable / n_total))
        message(sprintf("  - Countries with peaks: %d, without peaks: %d",
                       length(countries_with_peaks), length(countries_without_peaks)))

        return(data)
    }
}