#' Plot Epidemic Peaks from Detection Results
#'
#' This function loads the epidemic peak detection results and creates a multi-page
#' PDF with time series plots showing cases and identified peaks for each location.
#'
#' @param PATHS List of paths generated by get_paths() containing required data locations
#'
#' @return NULL (creates PDF file as side effect)
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Set up paths and create visualization
#' set_root_directory("~/MOSAIC")
#' PATHS <- get_paths()
#'
#' # Run peak detection first
#' est_epidemic_peaks(PATHS, method = 'algorithm')
#'
#' # Create visualization PDF
#' plot_epidemic_peaks(PATHS)
#' }
#'
#' @importFrom utils read.csv
#' @importFrom dplyr filter arrange mutate group_by summarise n
#' @importFrom ggplot2 ggplot geom_line geom_ribbon geom_point geom_vline
#' @importFrom ggplot2 scale_color_manual scale_fill_manual scale_x_date
#' @importFrom ggplot2 theme_minimal theme_void
#' @importFrom ggplot2 labs theme element_text element_blank element_rect element_line
#' @importFrom ggplot2 margin aes annotate
#' @importFrom ggplot2 ggsave
#' @importFrom gridExtra grid.arrange
#' @importFrom grDevices pdf dev.off
#' @importFrom graphics barplot hist par mtext
#'
plot_epidemic_peaks <- function(PATHS) {

  # Configuration parameters
  output_file <- "epidemic_peaks_visualization.pdf"
  height_per_plot <- 3
  plots_per_page <- 4

  # Define color palette from https://colorhunt.co/palette/ff3f33ffe6e1075b5e9fc87e
  color_peaks <- "#FF3F33"      # Bright red for peaks
  color_smooth <- "#075B5E"     # Dark teal for smoothed line
  color_reported_cases <- "#808080"  # Gray for reported cases
  color_grid <- "#E0E0E0"  # Light gray for grid


  # Load the peak detection results
  peaks_file <- file.path(PATHS$MODEL_INPUT, "param_epidemic_peaks.csv")

  if (!file.exists(peaks_file)) {
    stop(paste("Peak detection results not found at:", peaks_file,
               "\nPlease run est_epidemic_peaks() first."))
  }

  peaks_data <- read.csv(peaks_file, stringsAsFactors = FALSE)

  # Load the original cholera surveillance data
  data_file <- file.path(PATHS$DATA_CHOLERA_DAILY, "cholera_surveillance_daily_combined.csv")

  if (!file.exists(data_file)) {
    stop(paste("Cholera surveillance data not found at:", data_file))
  }

  cholera_data <- read.csv(data_file, stringsAsFactors = FALSE)

  # Get unique locations from peaks data
  locations <- unique(peaks_data$iso_code)
  n_locations <- length(locations)

  if (n_locations == 0) {
    stop("No locations found in peak detection results")
  }

  # Calculate PDF dimensions
  page_height <- height_per_plot * plots_per_page + 2  # Add margin
  n_pages <- ceiling(n_locations / plots_per_page)

  # Create output directory if needed
  output_dir <- file.path(PATHS$DOCS_FIGURES, "epidemic_peaks")
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # Full path for output file
  output_path <- file.path(output_dir, output_file)

  # Create list to store all plots
  plot_list <- list()

  for (loc_idx in seq_along(locations)) {

    loc <- locations[loc_idx]

    # Get data for this location
    loc_data <- cholera_data %>%
      filter(iso_code == loc) %>%
      arrange(date) %>%
      mutate(
        date = as.Date(date),
        cases = ifelse(is.na(cases), 0, cases)
      )

    # Skip if no data
    if (nrow(loc_data) == 0) {
      next
    }

    # Apply same smoothing as in est_epidemic_peaks
    window_size <- 21  # 3-week window for better smoothing
    n <- nrow(loc_data)
    loc_data$smoothed <- NA

    for (i in 1:n) {
      start_idx <- max(1, i - floor(window_size/2))
      end_idx <- min(n, i + floor(window_size/2))
      loc_data$smoothed[i] <- mean(loc_data$cases[start_idx:end_idx], na.rm = TRUE)
    }

    # Get peaks for this location
    loc_peaks <- peaks_data %>%
      filter(iso_code == loc)

    # Create ggplot
    p <- ggplot(loc_data, aes(x = date)) +
      # Background
      theme_minimal() +
      theme(
        plot.background = element_rect(fill = "white", color = NA),
        panel.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_line(color = color_grid, linewidth = 0.3),
        panel.grid.minor = element_blank(),
        plot.title = element_text(size = 14, face = "bold", hjust = 0, color = "gray20"),
        plot.subtitle = element_text(size = 10, hjust = 0, color = "gray40"),
        axis.title = element_text(size = 11, color = "gray30"),
        axis.text = element_text(size = 9, color = "gray40"),
        legend.position = "top",
        legend.background = element_rect(fill = "white", color = NA),
        legend.key = element_rect(fill = "white", color = NA),
        legend.title = element_blank(),
        legend.text = element_text(size = 9),
        plot.margin = margin(10, 15, 10, 10)
      )

    # Add epidemic periods as shaded regions first (so they're in background)
    if (nrow(loc_peaks) > 0) {
      for (j in 1:nrow(loc_peaks)) {
        p <- p +
          annotate("rect",
                   xmin = as.Date(loc_peaks$peak_start[j]),
                   xmax = as.Date(loc_peaks$peak_stop[j]),
                   ymin = -Inf, ymax = Inf,
                   fill = color_peaks, alpha = 0.1)
      }
    }

    # Add lines
    p <- p +
      # Reported cases line
      geom_line(aes(y = cases, color = "Reported cases"),
                linewidth = 0.4, alpha = 0.7) +
      # Smoothed line
      geom_line(aes(y = smoothed, color = "Smoothed (21-day mean)"),
                linewidth = 1.2)

    # Add peak markers and vertical lines
    if (nrow(loc_peaks) > 0) {
      # Get smoothed values at peak dates
      peak_values <- numeric(nrow(loc_peaks))
      for (j in 1:nrow(loc_peaks)) {
        peak_date <- as.Date(loc_peaks$peak_date[j])
        idx <- which(loc_data$date == peak_date)
        if (length(idx) > 0) {
          peak_values[j] <- loc_data$smoothed[idx[1]]
        } else {
          # Find closest date
          closest_idx <- which.min(abs(loc_data$date - peak_date))
          peak_values[j] <- loc_data$smoothed[closest_idx]
        }
      }

      loc_peaks$peak_value <- peak_values

      p <- p +
        # Peak points as triangles
        geom_point(data = loc_peaks,
                   aes(x = as.Date(peak_date), y = peak_value, color = "Detected peak"),
                   size = 3, shape = 17)
    }

    # Set color scale
    p <- p +
      scale_color_manual(
        values = c(
          "Reported cases" = color_reported_cases,
          "Smoothed (21-day mean)" = color_smooth,
          "Detected peak" = color_peaks
        ),
        breaks = c("Reported cases", "Smoothed (21-day mean)", "Detected peak")
      )

    # Add labels
    p <- p +
      labs(
        title = paste0(loc, ": ", nrow(loc_peaks), " epidemic peak",
                       ifelse(nrow(loc_peaks) == 1, "", "s"), " detected"),
        x = "Date",
        y = "Number of cases",
        color = NULL
      ) +
      # Add more year labels on x-axis
      scale_x_date(date_breaks = "1 year", date_labels = "%Y")

    # Add to plot list
    plot_list[[length(plot_list) + 1]] <- p
  }

  # Create PDF with multiple pages
  pdf(output_path, width = 10, height = page_height)

  # Arrange plots in pages
  n_plots <- length(plot_list)
  n_pages <- ceiling(n_plots / plots_per_page)

  for (page in 1:n_pages) {
    start_idx <- (page - 1) * plots_per_page + 1
    end_idx <- min(page * plots_per_page, n_plots)

    page_plots <- plot_list[start_idx:end_idx]

    # Pad with empty plots if needed to maintain consistent heights
    while (length(page_plots) < plots_per_page) {
      # Create an empty ggplot
      empty_plot <- ggplot() + theme_void()
      page_plots[[length(page_plots) + 1]] <- empty_plot
    }
    
    # Use grid.arrange to combine plots
    if (length(page_plots) > 0) {
      # Remove any NULL values from page_plots
      page_plots <- page_plots[!sapply(page_plots, is.null)]
      if (length(page_plots) > 0) {
        # Suppress grid.arrange warnings about nrow/ncol
        suppressWarnings({
          do.call(gridExtra::grid.arrange, c(page_plots, ncol = 1, nrow = plots_per_page))
        })
      }
    }
  }

  dev.off()
  
  # Create separate summary plot file
  summary_file <- "epidemic_peaks_summary.pdf"
  summary_path <- file.path(output_dir, summary_file)
  
  # Define summary plot colors (professional palette)
  summary_colors <- c("#2E86AB", "#A23B72", "#F18F01", "#C73E1D")
  
  # Calculate summary statistics
  peaks_by_location <- peaks_data %>%
    group_by(iso_code) %>%
    summarise(
      n_peaks = n(),
      mean_cases = mean(reported_cases, na.rm = TRUE),
      max_cases = max(reported_cases, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(desc(n_peaks))

  # Calculate epidemic durations
  peaks_data$duration_days <- as.numeric(
    as.Date(peaks_data$peak_stop) - as.Date(peaks_data$peak_start)
  )

  # Create summary plots in separate file
  pdf(summary_path, width = 12, height = 10)
  par(mfrow = c(2, 2), mar = c(5, 4, 4, 2), oma = c(2, 1, 2, 1))

  # 1. Number of peaks by location
  barplot(peaks_by_location$n_peaks,
          names.arg = peaks_by_location$iso_code,
          las = 2,
          col = summary_colors[1],
          main = "Number of Epidemic Peaks by Location",
          ylab = "Number of peaks",
          xlab = "")

  # 2. Distribution of reported cases at peaks
  hist(peaks_data$reported_cases,
       breaks = 30,
       col = summary_colors[2],
       main = "Distribution of Reported Cases at Peaks",
       xlab = "Reported cases",
       ylab = "Frequency")

  # 3. Distribution of epidemic durations
  peaks_data$duration_days[peaks_data$duration_days < 0] <- NA  # Handle any negative durations
  hist(na.omit(peaks_data$duration_days),
       breaks = 30,
       col = summary_colors[3],
       main = "Distribution of Epidemic Durations",
       xlab = "Duration (days)",
       ylab = "Frequency")

  # 4. Peak timing by month
  peaks_data$peak_month <- as.numeric(format(as.Date(peaks_data$peak_date), "%m"))

  # Create counts for all 12 months (some may be 0)
  all_months <- 1:12
  month_counts <- rep(0, 12)
  observed_months <- table(peaks_data$peak_month)
  month_counts[as.numeric(names(observed_months))] <- observed_months

  barplot(month_counts,
          names.arg = month.abb,
          col = summary_colors[4],
          main = "Seasonal Distribution of Epidemic Peaks",
          xlab = "Month",
          ylab = "Number of peaks")

  # Add overall title for summary page
  mtext(paste("Epidemic Peak Detection Summary -",
              length(unique(peaks_data$iso_code)), "locations,",
              nrow(peaks_data), "total peaks"),
        outer = TRUE, cex = 1.2, font = 2, line = 0)

  dev.off()

  message(paste("\nEpidemic peaks visualization saved to:", output_path))
  message(paste("Summary statistics saved to:", summary_path))
  message(paste("  - Locations plotted:", n_locations))
  message(paste("  - Total peaks shown:", nrow(peaks_data)))
  message(paste("  - PDF pages:", n_pages))

  invisible(NULL)

}

