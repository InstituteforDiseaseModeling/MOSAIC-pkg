#' Plot Posterior Predictive Checks from Ensemble Predictions
#'
#' Creates professional posterior predictive check (PPC) plots to assess model fit
#' using CSV files from stochastic/ensemble predictions. Generates three types of
#' diagnostic plots: density overlays, Q-Q plots, and residual analysis.
#'
#' @param predictions_dir Character string specifying directory containing prediction CSV files.
#'   Function will auto-discover predictions_ensemble_*.csv or predictions_stochastic_*.csv files.
#' @param predictions_files Character vector of specific CSV file paths to use.
#'   Overrides predictions_dir if provided.
#' @param locations Character vector of specific locations to plot. NULL (default) uses all locations.
#' @param model Legacy: A laser-cholera Model object (for backward compatibility).
#'   Not recommended - use CSV-based inputs instead.
#' @param output_dir Directory where PPC plots will be saved. Creates "ppc" subdirectory.
#' @param verbose Logical indicating whether to print progress messages (default: TRUE)
#'
#' @return NULL (invisibly). Creates PDF files as side effects.
#'
#' @details
#' Creates a multi-page PDF with PPC diagnostics: density overlays, calibration
#' scatter plots, Q-Q plots, residuals vs observed, and temporal patterns.
#'
#' Output files:
#' \itemize{
#'   \item ppc.pdf - Aggregate diagnostics (all locations combined)
#'   \item ppc_ISO.pdf - Per-location diagnostics (e.g., ppc_ETH.pdf, ppc_KEN.pdf)
#' }
#'
#' The function always creates both aggregate and per-location plots when multiple
#' locations are present in the data.
#'
#' The function uses ensemble predictions (median/mean) from CSV files generated by
#' plot_model_fit_stochastic() or plot_model_fit_stochastic_param(). This provides
#' better assessment than single model realizations.
#'
#' Color palette (Scientific Blue-Red):
#' - Observed data: #2E86AB (Professional blue)
#' - Predicted data: #A23B72 (Professional purple-red)
#' - Reference lines: #F18F01 (Orange)
#' - Smoothing curves: #C73E1D (Red-orange)
#' - Outlier highlights: #DC3545 (Alert red)
#' - Grid: #F5F5F5 (Light gray)
#'
#' @examples
#' \dontrun{
#' # From predictions directory (auto-discovers CSV files)
#' # Creates both aggregate and per-location plots
#' plot_model_ppc(
#'   predictions_dir = "output/1_bfrs/plots/predictions",
#'   output_dir = "output/1_bfrs/plots"
#' )
#'
#' # Specific locations only
#' plot_model_ppc(
#'   predictions_dir = "output/plots/predictions",
#'   output_dir = "output/plots",
#'   locations = c("ETH", "KEN")
#' )
#'
#' # Legacy mode (not recommended - aggregate only)
#' plot_model_ppc(model = best_model, output_dir = "output/plots")
#' }
#'
#' @export
#' @importFrom grDevices pdf dev.off rgb
#' @importFrom graphics plot lines abline legend mtext par grid polygon text points
#' @importFrom stats density loess predict quantile sd cor qqplot ppoints
#' @importFrom utils read.csv
#'
plot_model_ppc <- function(predictions_dir = NULL,
                          predictions_files = NULL,
                          locations = NULL,
                          model = NULL,
                          output_dir,
                          verbose = TRUE) {

    # ============================================================================
    # Input validation
    # ============================================================================

    if (missing(output_dir) || is.null(output_dir)) {
        stop("output_dir is required")
    }

    # Determine input mode
    use_csv <- !is.null(predictions_dir) || !is.null(predictions_files)
    use_model <- !is.null(model)

    if (!use_csv && !use_model) {
        stop("Must provide predictions_dir, predictions_files, or model")
    }

    # ============================================================================
    # Color Palette (matching plot_model_fit_stochastic.R)
    # ============================================================================

    palette <- list(
        observed      = "black",       # Observed data (all metrics)
        cases_pred    = "steelblue",   # Cases predictions
        deaths_pred   = "darkred",     # Deaths predictions
        reference     = "gray50",      # Reference lines
        smooth        = "darkorange",  # Smoothing lines
        alert         = "red",         # Alert/outliers
        grid          = "gray85"       # Grid lines
    )

    # Semi-transparent versions for shading and points
    col_shade_obs <- rgb(0, 0, 0, alpha = 0.2)              # Observed density (black)
    col_shade_cases <- rgb(70/255, 130/255, 180/255, alpha = 0.2)   # Cases (steelblue)
    col_shade_deaths <- rgb(139/255, 0, 0, alpha = 0.2)     # Deaths (darkred)
    col_points_cases <- rgb(70/255, 130/255, 180/255, alpha = 0.4)  # Cases scatter points
    col_points_deaths <- rgb(139/255, 0, 0, alpha = 0.4)    # Deaths scatter points

    # ============================================================================
    # Load data from CSV files or model object
    # ============================================================================

    if (use_csv) {
        # CSV-based input (preferred)
        if (verbose) message("=== Loading predictions from CSV files ===")

        if (!is.null(predictions_dir)) {
            # Auto-discover CSV files in directory
            ensemble_files <- list.files(predictions_dir,
                                        pattern = "^predictions_ensemble_.*\\.csv$",
                                        full.names = TRUE)
            stochastic_files <- list.files(predictions_dir,
                                          pattern = "^predictions_stochastic_.*\\.csv$",
                                          full.names = TRUE)

            # Prioritize ensemble over stochastic
            csv_files <- if (length(ensemble_files) > 0) {
                if (verbose) message("Using ensemble predictions (", length(ensemble_files), " files)")
                ensemble_files
            } else if (length(stochastic_files) > 0) {
                if (verbose) message("Using stochastic predictions (", length(stochastic_files), " files)")
                stochastic_files
            } else {
                stop("No prediction CSV files found in: ", predictions_dir)
            }
        } else {
            # Use explicitly provided files
            csv_files <- predictions_files
            if (verbose) message("Using ", length(csv_files), " specified prediction files")
        }

        # Load and combine all CSV files
        all_data <- do.call(rbind, lapply(csv_files, function(f) {
            tryCatch(read.csv(f, stringsAsFactors = FALSE),
                    error = function(e) {
                        warning("Failed to read: ", f, " - ", e$message)
                        NULL
                    })
        }))

        if (is.null(all_data) || nrow(all_data) == 0) {
            stop("Failed to load any valid prediction data from CSV files")
        }

        # Filter to specific locations if requested
        if (!is.null(locations)) {
            all_data <- all_data[all_data$location %in% locations, ]
            if (nrow(all_data) == 0) {
                stop("No data found for specified locations: ", paste(locations, collapse = ", "))
            }
        }

        available_locations <- unique(all_data$location)
        n_locations <- length(available_locations)

        if (verbose) {
            message("Loaded predictions for ", n_locations, " location(s): ",
                   paste(available_locations, collapse = ", "))
            message("Total rows: ", format(nrow(all_data), big.mark = ","))
        }

        # Determine which prediction column to use
        pred_col <- if ("predicted_median" %in% names(all_data)) {
            "predicted_median"
        } else if ("predicted_mean" %in% names(all_data)) {
            "predicted_mean"
        } else {
            stop("CSV must contain 'predicted_median' or 'predicted_mean' column")
        }

        if (verbose) message("Using prediction column: ", pred_col)

        # Store metadata
        data_source <- "ensemble predictions"

    } else {
        # Legacy model object input
        if (verbose) message("=== Extracting data from model object (legacy mode) ===")

        if (!inherits(model, "laser_cholera.metapop.model.Model") && !is.list(model)) {
            stop("model must be a laser-cholera Model object or a list")
        }

        location_names <- model$params$location_name
        obs_cases <- model$params$reported_cases
        obs_deaths <- model$params$reported_deaths
        pred_cases <- model$results$expected_cases
        pred_deaths <- model$results$disease_deaths

        # Convert to flat vectors (aggregate all locations)
        obs_cases_flat <- as.vector(obs_cases)
        obs_deaths_flat <- as.vector(obs_deaths)
        pred_cases_flat <- as.vector(pred_cases)
        pred_deaths_flat <- as.vector(pred_deaths)

        n_times <- if (is.matrix(obs_cases)) nrow(obs_cases) else length(obs_cases)
        n_locations <- if (is.matrix(obs_cases)) ncol(obs_cases) else 1

        # Create time vector
        time_vec <- rep(1:n_times, n_locations)

        available_locations <- if (!is.null(location_names)) location_names else "Location"
        data_source <- "single best model"

        if (verbose) {
            message("Extracted data for ", n_locations, " location(s)")
        }
    }

    # ============================================================================
    # Create output directory structure
    # ============================================================================

    ppc_dir <- file.path(output_dir, "ppc")
    if (!dir.exists(ppc_dir)) {
        dir.create(ppc_dir, recursive = TRUE)
        if (verbose) message("Created PPC directory: ", ppc_dir)
    }

    # ============================================================================
    # Helper function to create PPC plots from data
    # ============================================================================

    create_ppc_plots <- function(obs_cases_flat, pred_cases_flat,
                                 obs_deaths_flat, pred_deaths_flat,
                                 time_vec, location_label = "") {

        # Generate output file suffix
        suffix <- if (location_label != "") paste0("_", location_label) else ""

        # Remove NAs for valid comparisons
        valid_cases <- !is.na(obs_cases_flat) & !is.na(pred_cases_flat) &
                       obs_cases_flat > 0 & pred_cases_flat > 0
        valid_deaths <- !is.na(obs_deaths_flat) & !is.na(pred_deaths_flat) &
                        obs_deaths_flat > 0 & pred_deaths_flat > 0

        obs_cases_valid <- obs_cases_flat[valid_cases]
        pred_cases_valid <- pred_cases_flat[valid_cases]
        obs_deaths_valid <- obs_deaths_flat[valid_deaths]
        pred_deaths_valid <- pred_deaths_flat[valid_deaths]

        # Calculate residuals
        residuals_cases <- obs_cases_flat - pred_cases_flat
        residuals_deaths <- obs_deaths_flat - pred_deaths_flat

        if (verbose && suffix == "") {
            message("Valid data points:")
            message("  Cases: ", length(obs_cases_valid), " / ", length(obs_cases_flat))
            message("  Deaths: ", length(obs_deaths_valid), " / ", length(obs_deaths_flat))
        }

        # Add grid helper
        add_grid <- function() {
            grid(nx = NULL, ny = NULL, col = palette$grid, lty = 1, lwd = 0.5)
        }

        # ========================================================================
        # Open single multi-page PDF for all PPC plots
        # ========================================================================

        pdf(file.path(ppc_dir, paste0("ppc", suffix, ".pdf")), width = 14, height = 7)

        # ========================================================================
        # PAGE 1: Density overlays (1×2 layout)
        # ========================================================================

        par(mfrow = c(1, 2),
            mar = c(4.5, 4.5, 3, 2),
            oma = c(2, 2, 3, 1),
            mgp = c(2.5, 0.7, 0),
            las = 1,
            cex.axis = 0.9,
            cex.lab = 1.0,
            cex.main = 1.1,
            font.lab = 1,
            font.main = 2)

        # Panel 1: Cases density overlay
        if (length(obs_cases_valid) >= 2) {
            dens_obs <- tryCatch(
                density(log(obs_cases_valid + 1), bw = "SJ", adjust = 2),
                error = function(e) tryCatch(
                    density(log(obs_cases_valid + 1), bw = "nrd0", adjust = 2),
                    error = function(e2) density(log(obs_cases_valid + 1), bw = 0.5, adjust = 2)
                )
            )
            dens_pred <- tryCatch(
                density(log(pred_cases_valid + 1), bw = "SJ", adjust = 2),
                error = function(e) tryCatch(
                    density(log(pred_cases_valid + 1), bw = "nrd0", adjust = 2),
                    error = function(e2) density(log(pred_cases_valid + 1), bw = 0.5, adjust = 2)
                )
            )

            xlim_range <- range(c(dens_obs$x, dens_pred$x))
            ylim_range <- c(0, max(c(dens_obs$y, dens_pred$y)) * 1.1)

            plot(dens_obs, col = palette$observed, lwd = 2.5,
                 main = "Distribution of Log-Transformed Cases",
                 xlab = "log(Cases + 1)", ylab = "Density",
                 xlim = xlim_range, ylim = ylim_range, type = "n")
            add_grid()

            # Shaded areas
            polygon(c(dens_obs$x, rev(dens_obs$x)),
                   c(dens_obs$y, rep(0, length(dens_obs$y))),
                   col = col_shade_obs, border = NA)
            polygon(c(dens_pred$x, rev(dens_pred$x)),
                   c(dens_pred$y, rep(0, length(dens_pred$y))),
                   col = col_shade_cases, border = NA)

            # Lines
            lines(dens_obs, col = palette$observed, lwd = 2.5)
            lines(dens_pred, col = palette$cases_pred, lwd = 2.5)

            legend("topright",
                   legend = c("Observed", "Predicted"),
                   col = c(palette$observed, palette$cases_pred),
                   lwd = 2.5, bty = "n", cex = 0.9)
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient valid case data for density plot", cex = 1.2)
        }

        # Panel 2: Deaths density overlay
        if (length(obs_deaths_valid) >= 2) {
            dens_obs <- tryCatch(
                density(log(obs_deaths_valid + 1), bw = "SJ", adjust = 2),
                error = function(e) tryCatch(
                    density(log(obs_deaths_valid + 1), bw = "nrd0", adjust = 2),
                    error = function(e2) density(log(obs_deaths_valid + 1), bw = 0.5, adjust = 2)
                )
            )
            dens_pred <- tryCatch(
                density(log(pred_deaths_valid + 1), bw = "SJ", adjust = 2),
                error = function(e) tryCatch(
                    density(log(pred_deaths_valid + 1), bw = "nrd0", adjust = 2),
                    error = function(e2) density(log(pred_deaths_valid + 1), bw = 0.5, adjust = 2)
                )
            )

            xlim_range <- range(c(dens_obs$x, dens_pred$x))
            ylim_range <- c(0, max(c(dens_obs$y, dens_pred$y)) * 1.1)

            plot(dens_obs, col = palette$observed, lwd = 2.5,
                 main = "Distribution of Log-Transformed Deaths",
                 xlab = "log(Deaths + 1)", ylab = "Density",
                 xlim = xlim_range, ylim = ylim_range, type = "n")
            add_grid()

            polygon(c(dens_obs$x, rev(dens_obs$x)),
                   c(dens_obs$y, rep(0, length(dens_obs$y))),
                   col = col_shade_obs, border = NA)
            polygon(c(dens_pred$x, rev(dens_pred$x)),
                   c(dens_pred$y, rep(0, length(dens_pred$y))),
                   col = col_shade_deaths, border = NA)

            lines(dens_obs, col = palette$observed, lwd = 2.5)
            lines(dens_pred, col = palette$deaths_pred, lwd = 2.5)

            legend("topright",
                   legend = c("Observed", "Predicted"),
                   col = c(palette$observed, palette$deaths_pred),
                   lwd = 2.5, bty = "n", cex = 0.9)
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient valid death data for density plot", cex = 1.2)
        }

        title_text <- if (location_label != "") {
            paste0("Posterior Predictive Checks (", location_label, "): Density Overlays")
        } else {
            "Posterior Predictive Checks: Density Overlays"
        }
        mtext(title_text, outer = TRUE, cex = 1.3, font = 2, line = 1)

        # ========================================================================
        # PAGE 2: Observed vs Predicted Scatter Plots (1×2 layout)
        # ========================================================================

        par(mfrow = c(1, 2),
            mar = c(4.5, 4.5, 3, 2),
            oma = c(2, 2, 3, 1),
            mgp = c(2.5, 0.7, 0),
            las = 1,
            cex.axis = 0.9,
            cex.lab = 1.0,
            cex.main = 1.1,
            font.lab = 1,
            font.main = 2)

        # Panel 1: Observed vs Predicted Cases (scatter)
        if (length(obs_cases_valid) > 0) {
            plot(log(pred_cases_valid + 1), log(obs_cases_valid + 1),
                 pch = 19, col = col_points_cases, cex = 0.6,
                 xlab = "log(Predicted Cases + 1)",
                 ylab = "log(Observed Cases + 1)",
                 main = "Observed vs Predicted Cases",
                 panel.first = add_grid())

            abline(0, 1, col = palette$reference, lwd = 2, lty = 2)

            # LOESS smooth
            if (length(obs_cases_valid) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(log(obs_cases_valid + 1) ~ log(pred_cases_valid + 1), span = 0.75)
                    )
                    x_seq <- seq(min(log(pred_cases_valid + 1)),
                                max(log(pred_cases_valid + 1)),
                                length.out = 100)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))

                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$cases_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            cor_val <- cor(log(pred_cases_valid + 1), log(obs_cases_valid + 1))
            text(min(log(pred_cases_valid + 1)), max(log(obs_cases_valid + 1)),
                 paste0("r = ", round(cor_val, 3)),
                 pos = 4, cex = 0.9, font = 2)

            legend("bottomright",
                   legend = c("1:1 Line", "LOESS Smooth"),
                   col = c(palette$reference, palette$cases_pred),
                   lwd = c(2, 2.5), lty = c(2, 1),
                   bty = "n", cex = 0.9)
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient valid case data for scatter plot", cex = 1.2)
        }

        # Panel 2: Observed vs Predicted Deaths (scatter)
        if (length(obs_deaths_valid) > 0) {
            plot(log(pred_deaths_valid + 1), log(obs_deaths_valid + 1),
                 pch = 19, col = col_points_deaths, cex = 0.6,
                 xlab = "log(Predicted Deaths + 1)",
                 ylab = "log(Observed Deaths + 1)",
                 main = "Observed vs Predicted Deaths",
                 panel.first = add_grid())

            abline(0, 1, col = palette$reference, lwd = 2, lty = 2)

            if (length(obs_deaths_valid) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(log(obs_deaths_valid + 1) ~ log(pred_deaths_valid + 1), span = 0.75)
                    )
                    x_seq <- seq(min(log(pred_deaths_valid + 1)),
                                max(log(pred_deaths_valid + 1)),
                                length.out = 100)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))

                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$deaths_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            cor_val <- cor(log(pred_deaths_valid + 1), log(obs_deaths_valid + 1))
            text(min(log(pred_deaths_valid + 1)), max(log(obs_deaths_valid + 1)),
                 paste0("r = ", round(cor_val, 3)),
                 pos = 4, cex = 0.9, font = 2)

            legend("bottomright",
                   legend = c("1:1 Line", "LOESS Smooth"),
                   col = c(palette$reference, palette$deaths_pred),
                   lwd = c(2, 2.5), lty = c(2, 1),
                   bty = "n", cex = 0.9)
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient valid death data for scatter plot", cex = 1.2)
        }

        title_text <- if (location_label != "") {
            paste0("Posterior Predictive Checks (", location_label, "): Calibration Plots")
        } else {
            "Posterior Predictive Checks: Calibration Plots"
        }
        mtext(title_text, outer = TRUE, cex = 1.3, font = 2, line = 1)

        # ========================================================================
        # PAGE 3: Q-Q plots (1×2 layout - no change)
        # ========================================================================

        par(mfrow = c(1, 2),
            mar = c(4.5, 4.5, 3, 2),
            oma = c(2, 2, 3, 1),
            mgp = c(2.5, 0.7, 0),
            las = 1,
            cex.axis = 0.9,
            cex.lab = 1.0,
            cex.main = 1.1,
            font.lab = 1,
            font.main = 2)

        # Q-Q plot for cases
        valid_qq_cases <- !is.na(obs_cases_flat) & !is.na(pred_cases_flat)
        if (sum(valid_qq_cases) > 0) {
            obs_qq <- obs_cases_flat[valid_qq_cases]
            pred_qq <- pred_cases_flat[valid_qq_cases]

            qqplot(pred_qq, obs_qq,
                   pch = 19, col = col_points_cases, cex = 0.6,
                   xlab = "Predicted Cases (Quantiles)",
                   ylab = "Observed Cases (Quantiles)",
                   main = "Q-Q Plot: Cases",
                   panel.first = add_grid())
            abline(0, 1, col = palette$reference, lwd = 2.5, lty = 2)

            # Highlight large deviations
            if (sd(obs_qq) > 0 && length(obs_qq) > 5) {
                n <- length(obs_qq)
                probs <- ppoints(n)
                q_pred <- quantile(pred_qq, probs = probs)
                q_obs <- quantile(obs_qq, probs = probs)

                large_dev <- abs(q_obs - q_pred) > 2 * sd(obs_qq)
                if (any(large_dev)) {
                    points(q_pred[large_dev], q_obs[large_dev],
                          col = palette$alert, pch = 1, cex = 1.2, lwd = 2)
                }
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient data for Q-Q plot (cases)", cex = 1.2)
        }

        # Q-Q plot for deaths
        valid_qq_deaths <- !is.na(obs_deaths_flat) & !is.na(pred_deaths_flat)
        if (sum(valid_qq_deaths) > 0) {
            obs_qq <- obs_deaths_flat[valid_qq_deaths]
            pred_qq <- pred_deaths_flat[valid_qq_deaths]

            qqplot(pred_qq, obs_qq,
                   pch = 19, col = col_points_deaths, cex = 0.6,
                   xlab = "Predicted Deaths (Quantiles)",
                   ylab = "Observed Deaths (Quantiles)",
                   main = "Q-Q Plot: Deaths",
                   panel.first = add_grid())
            abline(0, 1, col = palette$reference, lwd = 2.5, lty = 2)

            if (sd(obs_qq) > 0 && length(obs_qq) > 5) {
                n <- length(obs_qq)
                probs <- ppoints(n)
                q_pred <- quantile(pred_qq, probs = probs)
                q_obs <- quantile(obs_qq, probs = probs)

                large_dev <- abs(q_obs - q_pred) > 2 * sd(obs_qq)
                if (any(large_dev)) {
                    points(q_pred[large_dev], q_obs[large_dev],
                          col = palette$alert, pch = 1, cex = 1.2, lwd = 2)
                }
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient data for Q-Q plot (deaths)", cex = 1.2)
        }

        title_text <- if (location_label != "") {
            paste0("Posterior Predictive Checks (", location_label, "): Quantile-Quantile Analysis")
        } else {
            "Posterior Predictive Checks: Quantile-Quantile Analysis"
        }
        mtext(title_text, outer = TRUE, cex = 1.3, font = 2, line = 1)

        # ========================================================================
        # PAGE 4: Residuals vs Observed (1×2 layout)
        # ========================================================================

        par(mfrow = c(1, 2),
            mar = c(4.5, 4.5, 3, 2),
            oma = c(2, 2, 3, 1),
            mgp = c(2.5, 0.7, 0),
            las = 1,
            cex.axis = 0.9,
            cex.lab = 1.0,
            cex.main = 1.1,
            font.lab = 1,
            font.main = 2)

        # Panel 1: Residuals vs Observed Cases
        valid_resid_cases <- !is.na(residuals_cases) & !is.na(obs_cases_flat)
        if (sum(valid_resid_cases) > 0) {
            plot(obs_cases_flat[valid_resid_cases], residuals_cases[valid_resid_cases],
                 pch = 19, col = col_points_cases, cex = 0.4,
                 xlab = "Observed Cases",
                 ylab = "Residuals (Observed - Predicted)",
                 main = "Residuals vs Observed: Cases",
                 panel.first = add_grid())
            abline(h = 0, col = palette$reference, lwd = 2.5, lty = 2)

            # LOESS smooth
            if (sum(valid_resid_cases) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(residuals_cases[valid_resid_cases] ~ obs_cases_flat[valid_resid_cases], span = 0.75)
                    )
                    x_seq <- seq(min(obs_cases_flat[valid_resid_cases]),
                                max(obs_cases_flat[valid_resid_cases]),
                                length.out = 100)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))
                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$cases_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            # ±2 SD lines
            sd_resid <- sd(residuals_cases[valid_resid_cases])
            if (!is.na(sd_resid) && sd_resid > 0) {
                abline(h = c(-2*sd_resid, 2*sd_resid), col = palette$grid, lty = 3, lwd = 1.5)
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient data for residual plot (cases)", cex = 1.2)
        }

        # Panel 2: Residuals vs Observed Deaths
        valid_resid_deaths <- !is.na(residuals_deaths) & !is.na(obs_deaths_flat)
        if (sum(valid_resid_deaths) > 0) {
            plot(obs_deaths_flat[valid_resid_deaths], residuals_deaths[valid_resid_deaths],
                 pch = 19, col = col_points_deaths, cex = 0.4,
                 xlab = "Observed Deaths",
                 ylab = "Residuals (Observed - Predicted)",
                 main = "Residuals vs Observed: Deaths",
                 panel.first = add_grid())
            abline(h = 0, col = palette$reference, lwd = 2.5, lty = 2)

            if (sum(valid_resid_deaths) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(residuals_deaths[valid_resid_deaths] ~ obs_deaths_flat[valid_resid_deaths], span = 0.75)
                    )
                    x_seq <- seq(min(obs_deaths_flat[valid_resid_deaths]),
                                max(obs_deaths_flat[valid_resid_deaths]),
                                length.out = 100)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))
                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$deaths_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            sd_resid <- sd(residuals_deaths[valid_resid_deaths])
            if (!is.na(sd_resid) && sd_resid > 0) {
                abline(h = c(-2*sd_resid, 2*sd_resid), col = palette$grid, lty = 3, lwd = 1.5)
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient data for residual plot (deaths)", cex = 1.2)
        }

        title_text <- if (location_label != "") {
            paste0("Posterior Predictive Checks (", location_label, "): Residuals vs Observed")
        } else {
            "Posterior Predictive Checks: Residuals vs Observed"
        }
        mtext(title_text, outer = TRUE, cex = 1.3, font = 2, line = 1)

        # ========================================================================
        # PAGE 5: Temporal Residual Patterns (1×2 layout)
        # ========================================================================

        par(mfrow = c(1, 2),
            mar = c(4.5, 4.5, 3, 2),
            oma = c(2, 2, 3, 1),
            mgp = c(2.5, 0.7, 0),
            las = 1,
            cex.axis = 0.9,
            cex.lab = 1.0,
            cex.main = 1.1,
            font.lab = 1,
            font.main = 2)

        # Panel 1: Temporal residuals - Cases
        valid_time_cases <- !is.na(residuals_cases) & !is.na(time_vec)
        if (sum(valid_time_cases) > 0) {
            plot(time_vec[valid_time_cases], residuals_cases[valid_time_cases],
                 pch = 19, col = col_points_cases, cex = 0.3,
                 xlab = "Time Index",
                 ylab = "Residuals (Observed - Predicted)",
                 main = "Temporal Pattern of Case Residuals",
                 panel.first = add_grid())
            abline(h = 0, col = palette$reference, lwd = 2.5, lty = 2)

            if (sum(valid_time_cases) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(residuals_cases[valid_time_cases] ~ time_vec[valid_time_cases], span = 0.3)
                    )
                    x_seq <- seq(min(time_vec[valid_time_cases]),
                                max(time_vec[valid_time_cases]),
                                length.out = 200)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))
                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$cases_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            sd_resid <- sd(residuals_cases[valid_time_cases])
            if (!is.na(sd_resid) && sd_resid > 0) {
                abline(h = c(-2*sd_resid, 2*sd_resid), col = palette$grid, lty = 3, lwd = 1.5)
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient temporal data (cases)", cex = 1.2)
        }

        # Panel 2: Temporal residuals - Deaths
        valid_time_deaths <- !is.na(residuals_deaths) & !is.na(time_vec)
        if (sum(valid_time_deaths) > 0) {
            plot(time_vec[valid_time_deaths], residuals_deaths[valid_time_deaths],
                 pch = 19, col = col_points_deaths, cex = 0.3,
                 xlab = "Time Index",
                 ylab = "Residuals (Observed - Predicted)",
                 main = "Temporal Pattern of Death Residuals",
                 panel.first = add_grid())
            abline(h = 0, col = palette$reference, lwd = 2.5, lty = 2)

            if (sum(valid_time_deaths) > 10) {
                tryCatch({
                    lo <- suppressWarnings(
                        loess(residuals_deaths[valid_time_deaths] ~ time_vec[valid_time_deaths], span = 0.3)
                    )
                    x_seq <- seq(min(time_vec[valid_time_deaths]),
                                max(time_vec[valid_time_deaths]),
                                length.out = 200)
                    lo_pred <- suppressWarnings(predict(lo, x_seq))
                    if (!any(is.na(lo_pred))) {
                        lines(x_seq, lo_pred, col = palette$deaths_pred, lwd = 2.5)
                    }
                }, error = function(e) {})
            }

            sd_resid <- sd(residuals_deaths[valid_time_deaths])
            if (!is.na(sd_resid) && sd_resid > 0) {
                abline(h = c(-2*sd_resid, 2*sd_resid), col = palette$grid, lty = 3, lwd = 1.5)
            }
        } else {
            plot.new()
            text(0.5, 0.5, "Insufficient temporal data (deaths)", cex = 1.2)
        }

        title_text <- if (location_label != "") {
            paste0("Posterior Predictive Checks (", location_label, "): Temporal Residual Patterns")
        } else {
            "Posterior Predictive Checks: Temporal Residual Patterns"
        }
        mtext(title_text, outer = TRUE, cex = 1.3, font = 2, line = 1)

        # ========================================================================
        # Close multi-page PDF
        # ========================================================================

        dev.off()

        if (verbose) {
            suffix_text <- if (suffix != "") paste0(" (", location_label, ")") else ""
            output_file <- paste0("ppc", suffix, ".pdf")
            message("  PPC plot", suffix_text, " saved: ", output_file)
        }
    }

    # ============================================================================
    # Create plots based on mode
    # ============================================================================

    if (use_csv) {
        # CSV mode: always create both aggregate and per-location plots

        # Aggregate plots (all locations combined)
        if (verbose) message("\n=== Creating Aggregate PPC Plots ===")

        # Flatten all locations together
        obs_cases_flat <- all_data$observed[all_data$metric == "Cases"]
        pred_cases_flat <- all_data[[pred_col]][all_data$metric == "Cases"]
        obs_deaths_flat <- all_data$observed[all_data$metric == "Deaths"]
        pred_deaths_flat <- all_data[[pred_col]][all_data$metric == "Deaths"]

        # Create time vector
        n_per_location <- sum(all_data$location == available_locations[1] & all_data$metric == "Cases")
        time_vec <- rep(1:n_per_location, n_locations)

        create_ppc_plots(obs_cases_flat, pred_cases_flat,
                       obs_deaths_flat, pred_deaths_flat,
                       time_vec, location_label = "")

        # Per-location plots (if multiple locations present)
        if (n_locations > 1) {
            if (verbose) message("\n=== Creating Per-Location PPC Plots ===")

            for (loc in available_locations) {
                if (verbose) message("  Processing location: ", loc)

                # Filter to this location
                loc_data <- all_data[all_data$location == loc, ]

                obs_cases_loc <- loc_data$observed[loc_data$metric == "Cases"]
                pred_cases_loc <- loc_data[[pred_col]][loc_data$metric == "Cases"]
                obs_deaths_loc <- loc_data$observed[loc_data$metric == "Deaths"]
                pred_deaths_loc <- loc_data[[pred_col]][loc_data$metric == "Deaths"]

                # Time vector for this location
                time_vec_loc <- 1:length(obs_cases_loc)

                create_ppc_plots(obs_cases_loc, pred_cases_loc,
                               obs_deaths_loc, pred_deaths_loc,
                               time_vec_loc, location_label = loc)
            }
        }

    } else {
        # Legacy model mode: only aggregate plots
        if (verbose) message("\n=== Creating PPC Plots (Legacy Mode) ===")

        create_ppc_plots(obs_cases_flat, pred_cases_flat,
                       obs_deaths_flat, pred_deaths_flat,
                       time_vec, location_label = "")
    }

    # ============================================================================
    # Final summary
    # ============================================================================

    if (verbose) {
        message("\n=== PPC Plots Complete ===")
        message("Output directory: ", ppc_dir)
        message("Data source: ", data_source)

        if (use_csv) {
            message("Locations processed: ", paste(available_locations, collapse = ", "))
            if (n_locations > 1) {
                message("Created both aggregate and per-location plots")
            } else {
                message("Created aggregate plot (single location)")
            }
        }
    }

    invisible(NULL)
}
