#' Plot Clustering of Countries Based on Seasonal Dynamics
#'
#' This function visualizes the clustering of countries based on seasonal precipitation or cholera cases. It generates a map showing the clusters, and a multi-panel plot showing the fitted Fourier series values for each cluster.
#'
#' @param PATHS A list containing paths where processed climate, cholera, and fitted data are stored. Typically generated by the `get_paths()` function and should include:
#' \itemize{
#'   \item \strong{DATA_SHAPEFILES}: Path to the directory containing shapefiles for African countries.
#'   \item \strong{DOCS_TABLES}: Path to load the processed precipitation, fitted values, and clustering results.
#'   \item \strong{DOCS_FIGURES}: Path to save the output plot.
#' }
#' @param use_cases A logical value. If `TRUE`, clustering is based on Fourier series fitted to cholera cases. If `FALSE`, clustering is based on precipitation.
#' @param set_inferred_to_na A logical value. If `TRUE`, inferred countries are set to `NA` in the clustering. Default is `TRUE` when using precipitation, `FALSE` when using cases.
#' @param clustering_method A character string specifying the clustering method. Options are `"kmeans"`, `"hierarchical"`, `"dbscan"`, or `"knn"`. Default is `"hierarchical"`.
#' @param k An integer specifying the number of clusters for k-means and hierarchical clustering. Default is 4.
#'
#' @return The function generates and saves a PNG file showing the clustering of countries based on seasonal dynamics.
#'
#' @importFrom ggplot2 ggplot aes geom_sf geom_line geom_hline facet_wrap scale_fill_manual scale_color_manual labs theme_minimal theme element_text element_blank
#' @importFrom dplyr filter left_join select mutate
#' @importFrom tidyr spread
#' @importFrom cowplot plot_grid
#' @importFrom utils read.csv
#' @importFrom glue glue
#' @importFrom RColorBrewer brewer.pal
#' @importFrom FNN get.knnx
#' @importFrom sf st_read st_centroid st_transform st_coordinates
#' @importFrom dbscan dbscan
#' @export

plot_seasonal_clustering <- function(PATHS,
                                     use_cases = FALSE,
                                     set_inferred_to_na = TRUE,
                                     clustering_method = "hierarchical",
                                     k = 4) {

     # Load required data
     combined_fitted_values <- utils::read.csv(file.path(PATHS$DOCS_TABLES, "pred_seasonal_dynamics.csv"), stringsAsFactors = FALSE)
     africa <- sf::st_read(dsn = file.path(PATHS$DATA_SHAPEFILES, "AFRICA_ADM0.shp"), quiet = TRUE)

     # Determine whether to use cases or precipitation for clustering
     if (use_cases) {
          fitted_column <- "fitted_values_fourier_cases"
          plot_title <- "Fourier series fitted to cholera cases (2023-2024)"
          map_title <- "Clustering of countries based on seasonal transmission"
     } else {
          fitted_column <- "fitted_values_fourier_precip"
          plot_title <- "Fourier series fitted to weekly precipitation (1994-2024)"
          map_title <- "Clustering of countries based on seasonal precipitation"
          set_inferred_to_na <- FALSE  # If using precipitation, inferred countries are not set to NA
     }

     # Prepare data for clustering
     precip_fitted_df <- combined_fitted_values %>%
          dplyr::filter(!is.na(!!sym(fitted_column))) %>%
          dplyr::select(iso_code, week, !!sym(fitted_column)) %>%
          tidyr::spread(key = week, value = !!sym(fitted_column))  # Reshape to have one row per country, weeks as columns

     # Remove rows with NA values
     precip_fitted_df <- na.omit(precip_fitted_df)

     # Perform clustering based on the chosen method
     precip_matrix <- precip_fitted_df %>% dplyr::select(-iso_code)
     if (clustering_method == "kmeans") {
          set.seed(123)
          clustering_result <- kmeans(precip_matrix, centers = k)
          precip_fitted_df$cluster <- clustering_result$cluster
     } else if (clustering_method == "hierarchical") {
          dist_matrix <- dist(precip_matrix)
          hc <- hclust(dist_matrix, method = "ward.D2")
          precip_fitted_df$cluster <- cutree(hc, k = k)
     } else if (clustering_method == "dbscan") {
          set.seed(123)
          dbscan_result <- dbscan(precip_matrix, eps = 1, minPts = 3)
          precip_fitted_df$cluster <- as.factor(dbscan_result$cluster)
     } else if (clustering_method == "knn") {
          set.seed(123)
          knn_distances <- FNN::get.knnx(precip_matrix, k = k)$nn.dist
          knn_clustering <- kmeans(knn_distances, centers = k)
          precip_fitted_df$cluster <- knn_clustering$cluster
     } else {
          stop("Invalid clustering method specified.")
     }

     # Merge clustering results with spatial data
     africa_with_clusters <- africa %>%
          dplyr::left_join(precip_fitted_df %>% dplyr::select(iso_code, cluster), by = c("iso_a3" = "iso_code"))

     # Optionally set inferred countries to NA
     if (set_inferred_to_na) {
          countries_with_case_data <- unique(combined_fitted_values$iso_code[is.na(combined_fitted_values$inferred_from_neighbor)])
          sel <- !(africa_with_clusters$iso_a3 %in% countries_with_case_data)
          africa_with_clusters[sel, 'cluster'] <- NA
     }

     # Define cluster colors
     cluster_colors <- RColorBrewer::brewer.pal(length(unique(africa_with_clusters$cluster)) + 1, "Set1")
     cluster_colors <- RColorBrewer::brewer.pal(9, "Set1")[-6]
     cluster_colors <- cluster_colors[1:length(unique(africa_with_clusters$cluster))]

     # Step 5: Plot the map with countries colored by their cluster assignments
     map_plot <- ggplot(africa_with_clusters) +
          geom_sf(aes(fill = as.factor(cluster))) +
          scale_fill_manual(values = cluster_colors, na.value = "grey95") +
          labs(title = stringr::str_wrap(map_title, 30), subtitle = "", fill = "Cluster") +
          theme_minimal() +
          theme(legend.position = "bottom", plot.title = element_text(hjust=0.5))

     # Step 6: Create a multi-panel plot to show Fourier fitted values for each cluster
     fitted_for_plot <- combined_fitted_values %>%
          dplyr::left_join(precip_fitted_df %>% dplyr::select(iso_code, cluster), by = "iso_code") %>%
          dplyr::filter(!is.na(cluster))

     facet_plot <- ggplot(fitted_for_plot, aes(x = week, y = !!sym(fitted_column), group = iso_code, color = as.factor(cluster))) +
          geom_hline(yintercept = 0) +
          geom_line(alpha = 1) +
          facet_wrap(~ cluster, scales = "free_y") +
          scale_color_manual(values = cluster_colors) +
          scale_x_continuous(breaks = c(1, 10, 20, 30, 40, 52)) +
          labs(title = stringr::str_wrap(plot_title, 40), x = "Week", y = "Z-score") +
          theme_minimal() +
          theme(legend.position = "none", panel.grid.minor = element_blank(), plot.title = element_text(hjust=0.5))

     # Step 7: Combine the map and the facet plot using cowplot
     combined_plot <- cowplot::plot_grid(map_plot, facet_plot, ncol = 2, rel_widths = c(1, 1.5), labels=c("A", "B"))

     print(combined_plot)

     # Save the plot as an image
     png_filename <- file.path(PATHS$DOCS_FIGURES, glue::glue("seasonal_{ifelse(use_cases, 'cases', 'precip')}_{clustering_method}_cluster{ifelse(set_inferred_to_na, '_inferred', '')}.png"))
     png(filename = png_filename, width = 8, height = 5, units = "in", res = 300)
     print(combined_plot)
     dev.off()

     message(glue::glue("Clustering plot saved to {png_filename}."))

}
